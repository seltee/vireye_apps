#include "field.h"

// Graphics representation of each block
const uint8 sprites[][144] = {
	{
		0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02,
		0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x03, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07,
		0x02, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x02,
	},
	{
		0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02,
		0x03, 0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x03, 0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
		0x03, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09,
		0x02, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x02,
	},
	{
		0x03, 0x03, 0x03, 0x02, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x03, 0x03,
		0x03, 0x05, 0x0b, 0x02, 0x03, 0x05, 0x05, 0x0b, 0x02, 0x03, 0x05, 0x0b,
		0x03, 0x05, 0x05, 0x05, 0x03, 0x05, 0x05, 0x05, 0x05, 0x03, 0x05, 0x0b,
		0x03, 0x0b, 0x0b, 0x0b, 0x03, 0x05, 0x0b, 0x0b, 0x0b, 0x03, 0x05, 0x0b,
		0x03, 0x0b, 0x02, 0x02, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, 0x02, 0x05, 0x0b,
		0x03, 0x0b, 0x02, 0x02, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, 0x02, 0x05, 0x0b,
		0x03, 0x0b, 0x02, 0x02, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, 0x02, 0x05, 0x0b,
		0x03, 0x0b, 0x02, 0x02, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, 0x02, 0x05, 0x0b,
		0x03, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x0b, 0x0b, 0x05, 0x05, 0x0b,
		0x03, 0x05, 0x0b, 0x0b, 0x05, 0x05, 0x05, 0x0b, 0x05, 0x05, 0x05, 0x0b,
		0x03, 0x05, 0x0b, 0x02, 0x05, 0x05, 0x05, 0x0b, 0x02, 0x05, 0x05, 0x0b,
		0x0b, 0x0b, 0x0b, 0x02, 0x0b, 0x0b, 0x0b, 0x0b, 0x02, 0x0b, 0x0b, 0x0b,
	},
	{
		0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02,
		0x03, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d,
		0x03, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0c, 0x0c, 0x0d,
		0x03, 0x0c, 0x0d, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x0c, 0x0d,
		0x03, 0x0c, 0x0d, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x0c, 0x0d,
		0x03, 0x0c, 0x0d, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x0c, 0x0d,
		0x03, 0x0c, 0x0d, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x0c, 0x0d,
		0x03, 0x0c, 0x0d, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x0c, 0x0d,
		0x03, 0x0c, 0x0d, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x0c, 0x0d,
		0x03, 0x0c, 0x0c, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0c, 0x0c, 0x0d,
		0x03, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d,
		0x02, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x02,
	},
	{
		0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		0x03, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0f,
		0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f,
		0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f,
		0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f,
		0x03, 0x0e, 0x03, 0x03, 0x03, 0x03, 0x0e, 0x03, 0x03, 0x03, 0x03, 0x0f,
		0x03, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0f,
		0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f,
		0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f,
		0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f, 0x02, 0x02, 0x02, 0x03, 0x0f,
		0x03, 0x0e, 0x03, 0x03, 0x03, 0x03, 0x0e, 0x03, 0x03, 0x03, 0x03, 0x0f,
		0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
	}
};

// Class initialization - with, size, data. You may wonder, why I'm not using new? It's simply not works :D 
void Field::init(int16 width, int16 height, uint8 *data){
	this->width = width;
	this->height = height;
	this->data = data;
	arrSize = width*height;
	memset(data, 0, arrSize);
	realWidth = 0;
}

// Draw the field at position
void Field::draw(int16 x, int16 y){
	//we can't use matrix, because it works only with sprites size multiples of two
	for (int16 iy = 0; iy < height; iy++){
		int16 syPosition = iy*width;
		int16 yRealPosition = iy*12;
		for (uint16 ix = 0; ix < width; ix++){
			int16 stPosition = syPosition + ix;
			if (data[stPosition]){
				displaySprite(sprites[data[stPosition]-1], x + ix*12, y + yRealPosition, 12, 12, SPRITE_FLAG_NO, false);
			}
		}
	}
}

// Set one block in the position with all necessary checking
void Field::set(int16 x, int16 y, uint8 sprite){
	uint16 vl;
	if (x >= 0 && x < width && y >= 0 && y < height && sprite >= 0 && sprite <= FIELD_SPRITE_COUNT){
		data[x + y*width] = sprite;
	}
}

// Get block, if position is outside - returns 0. Usefull.
uint8 Field::get(int16 x, int16 y){
	if (x >= 0 && x < width && y >= 0 && y < height){
		return data[x + y*width];
	}
	return 0;
}

// Real with calculated by occupied blocks
int16 Field::getRealWidth(){
	return realWidth;
}

// Width of field
int16 Field::getWidth(){
	return width;
}

// Height of field
int16 Field::getHeight(){
	return height;
}

// Compares blocks in two fields, current and another one.
// If there some hits - returns true
bool Field::check(int16 x, int16 y, Field *field){
	int16 tWidth = field->getWidth();
	int16 tHeight = field->getHeight();
	for (int16 iy = 0; iy < tHeight; iy++){
		for (int16 ix = 0; ix < tWidth; ix++){
			if (field->get(ix, iy)){
				if (get(ix+x, iy+y)){
					return true;
				}
			}
		}	
	}
	return false;
}

// Same as check, but with shift down
bool Field::checkDown(int16 x, int16 y, Field *field){
	int16 tWidth = field->getWidth();
	int16 tHeight = field->getHeight();
	for (int16 iy = 0; iy < tHeight; iy++){
		for (int16 ix = 0; ix < tWidth; ix++){
			if (field->get(ix, iy)){
				if (get(ix+x, iy+y+1)){
					return true;
				}
				if (iy + y >= height-1){
					return true;
				}
			}
		}	
	}
	return false;
}

// Same as check, but with shift left
bool Field::checkLeft(int16 x, int16 y, Field *field){
	return check(x - 1, y, field);
}

// Same as check, but with shift right
bool Field::checkRight(int16 x, int16 y, Field *field){
	return check(x + 1, y, field);
}

// Copies another field to current
void Field::copy(int16 x, int16 y, Field *field){
	uint8 t;
	int16 ix, iy;
	int16 tWidth = field->getWidth();
	int16 tHeight = field->getHeight();
	for (iy = 0; iy < tHeight; iy++){
		for (ix = 0; ix < tWidth; ix++){
			t = field->get(ix, iy);
			if (t){
				set(ix+x, iy+y, t);
			}
		}	
	}
}

// Rotates current field and shifts to top-left conner
void Field::rotate(){
	memcpy(prev, data, width*width);
	uint8 buffer[16], ix, iy;
	for (iy = 0; iy < width; iy++){
		for (ix = 0; ix < width; ix++){
			buffer[(width-ix-1)+iy*width] = data[iy+ix*width];
		}
	}
	memcpy(data, buffer, width*width);
	clearGups();
}

// Returns to state before rotation
void Field::revert(){
	memcpy(data, prev, width*width);
}

// Shifts to top-left conner
void Field::clearGups(){
	uint8 hGup, vGup, ix, iy;
	for (hGup = 0; hGup < 3; hGup++){
		if (hasSomeInColumn(hGup)){
			break;
		}
	}
	
	for (vGup = 0; vGup < 3; vGup++){
		if (hasSomeInRow(vGup)){
			break;
		}
	}
	
	if (hGup || vGup){
		for (iy = 0; iy < height; iy++){
			for (ix = 0; ix < width; ix++){
				set(ix, iy, get(ix+hGup, iy+vGup));
			}
		}
	}
}

// Return true if there are blocks in column
bool Field::hasSomeInColumn(uint8 column){
	for (uint8 i = 0; i < height; i++){
		if (get(column, i)){
			return true;
		}
	}
	return false;
}

// Return true if there are blocks in row
bool Field::hasSomeInRow(uint8 row){
	for (uint8 i = 0; i < width; i++){
		if (get(i, row)){
			return true;
		}
	}
	return false;	
}

// Calculates width based on last block in rows
void Field::calcRealWidth(){
	realWidth = 0;
	for (uint16 i = 0; i < width; i++){
		if (hasSomeInColumn(i)){
			realWidth = i+1;
		}
	}
}

// Searches for full lines and removes them. Returns number of removed line
int8 Field::explode(){
	for (uint8 iy = 0; iy < height; iy++){
		uint8 ix = 0;
		while(get(ix, iy)) ix++;
		if (ix == width){
			for(uint8 dey = iy; dey != 255; dey--){
				for(ix = 0; ix < width; ix++){
					set(ix, dey, get(ix, dey-1));
				}
			}
			return iy;
		}
	}
	return 255;
}

